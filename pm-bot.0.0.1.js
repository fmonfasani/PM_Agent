// pm-bot.js - Project Manager 0.0.1
// Requisitos: Node.js, tokens de Anthropic y GitHub

const fs = require('fs');
const path = require('path');

// Verificar si las dependencias est√°n instaladas
try {
  var { Anthropic } = require('@anthropic-ai/sdk');
  var { Octokit } = require('@octokit/rest');
} catch (error) {
  console.error('‚ùå Error: Dependencias no instaladas.');
  console.log('üîß Ejecuta: npm install @anthropic-ai/sdk @octokit/rest');
  process.exit(1);
}

const { exec } = require('child_process');
const util = require('util');

const execAsync = util.promisify(exec);

class SimplePM {
  constructor() {
    // Verificar variables de entorno
    this.checkEnvVars();
    
    this.anthropic = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY
    });
    
    this.github = new Octokit({
      auth: process.env.GITHUB_TOKEN
    });
    
    this.projectConfig = {
      owner: process.env.GITHUB_OWNER,
      repo: process.env.GITHUB_REPO,
      workingDir: './temp_project'
    };
    
    this.isWorking = true;
    this.taskQueue = [];
    this.currentTask = null;
  }

  checkEnvVars() {
    const requiredEnvVars = ['ANTHROPIC_API_KEY', 'GITHUB_TOKEN', 'GITHUB_OWNER', 'GITHUB_REPO'];
    const missing = requiredEnvVars.filter(v => !process.env[v]);
    
    if (missing.length > 0) {
      console.error('‚ùå Variables de entorno faltantes:', missing.join(', '));
      console.log('\nüìã Configuraci√≥n requerida:');
      console.log('export ANTHROPIC_API_KEY="your_anthropic_key"');
      console.log('export GITHUB_TOKEN="your_github_token"');
      console.log('export GITHUB_OWNER="your_github_username"');
      console.log('export GITHUB_REPO="your_repo_name"');
      console.log('\nüí° O crea un archivo .env con estas variables');
      process.exit(1);
    }
  }

  // üéØ CORE: Recibir tarea y ejecutar ciclo completo
  async processTask(taskDescription) {
    console.log(`\nüöÄ PM Bot iniciando tarea: ${taskDescription}`);
    
    this.currentTask = {
      id: Date.now().toString(),
      description: taskDescription,
      status: 'in_progress',
      startTime: new Date(),
      steps: []
    };

    try {
      // PASO 1: Analizar tarea y crear plan
      const plan = await this.createExecutionPlan(taskDescription);
      console.log('üìã Plan creado:', plan.summary);
      
      // PASO 2: Generar c√≥digo
      const code = await this.generateCode(plan);
      console.log('üíª C√≥digo generado');
      
      // PASO 3: Crear estructura de proyecto
      await this.setupProject(code);
      console.log('üìÅ Proyecto configurado');
      
      // PASO 4: Ejecutar tests
      const testResults = await this.runTests();
      console.log('üß™ Tests ejecutados:', testResults.success ? '‚úÖ' : '‚ùå');
      
      // PASO 5: Si tests pasan, subir a GitHub
      if (testResults.success) {
        const commitUrl = await this.pushToGitHub(code, plan);
        console.log('üì§ C√≥digo subido a GitHub:', commitUrl);
        
        // PASO 6: Reportar √©xito
        await this.reportSuccess(plan, testResults, commitUrl);
      } else {
        // PASO 7: Si fallan, intentar arreglar
        await this.handleTestFailure(testResults);
      }
      
    } catch (error) {
      await this.handleError(error);
    }
  }

  // üß† AN√ÅLISIS: Crear plan de ejecuci√≥n
  async createExecutionPlan(taskDescription) {
    const prompt = `
Eres un PM experto. Analiza esta tarea y crea un plan de ejecuci√≥n:

TAREA: ${taskDescription}

Responde en JSON con esta estructura exacta:
{
  "summary": "Resumen breve de la tarea",
  "type": "frontend",
  "technology": "javascript",
  "files": [
    {
      "name": "main.js",
      "purpose": "c√≥digo principal",
      "priority": "high"
    }
  ],
  "tests": [
    {
      "type": "unit",
      "description": "test del c√≥digo principal"
    }
  ],
  "acceptance_criteria": ["funciona correctamente", "incluye tests"]
}

IMPORTANTE: Responde SOLO con el JSON, sin texto adicional.
`;

    const response = await this.anthropic.messages.create({
      model: 'claude-3-5-sonnet-20241022',
      max_tokens: 1000,
      messages: [{ role: 'user', content: prompt }]
    });

    try {
      return JSON.parse(response.content[0].text);
    } catch (error) {
      console.error('Error parsing plan JSON:', response.content[0].text);
      // Plan por defecto si falla el parsing
      return {
        summary: taskDescription,
        type: "utility",
        technology: "javascript",
        files: [{ name: "main.js", purpose: "c√≥digo principal", priority: "high" }],
        tests: [{ type: "unit", description: "test b√°sico" }],
        acceptance_criteria: ["funcionalidad implementada"]
      };
    }
  }

  // üíª DESARROLLO: Generar c√≥digo
  async generateCode(plan) {
    const prompt = `
Como desarrollador experto, implementa este plan:

PLAN: ${JSON.stringify(plan, null, 2)}

Genera c√≥digo completo y funcional. 

Responde SOLO con este JSON exacto:
{
  "files": [
    {
      "path": "main.js",
      "content": "// C√≥digo JavaScript aqu√≠\nfunction example() {\n  return 'Hello World';\n}\nmodule.exports = example;",
      "type": "main"
    },
    {
      "path": "test.js",
      "content": "// Tests aqu√≠\nconst main = require('./main');\nconsole.log('Test passed:', main() === 'Hello World');",
      "type": "test"
    },
    {
      "path": "package.json",
      "content": "{\n  \"name\": \"generated-project\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"test\": \"node test.js\"\n  }\n}",
      "type": "config"
    }
  ],
  "setup_commands": ["echo 'Setup complete'"],
  "run_command": "npm test"
}

IMPORTANTE: Responde SOLO con el JSON, sin texto adicional.
`;

    const response = await this.anthropic.messages.create({
      model: 'claude-3-5-sonnet-20241022',
      max_tokens: 4000,
      messages: [{ role: 'user', content: prompt }]
    });

    try {
      return JSON.parse(response.content[0].text);
    } catch (error) {
      console.error('Error parsing code JSON:', response.content[0].text);
      // C√≥digo por defecto si falla el parsing
      return {
        files: [
          {
            path: "main.js",
            content: `// Implementaci√≥n para: ${plan.summary}\nfunction main() {\n  console.log('Implementaci√≥n generada');\n  return true;\n}\nmodule.exports = main;`,
            type: "main"
          },
          {
            path: "test.js",
            content: `const main = require('./main');\nconsole.log('‚úÖ Test passed:', main() === true);`,
            type: "test"
          }
        ],
        setup_commands: [],
        run_command: "node test.js"
      };
    }
  }

  // üìÅ SETUP: Configurar proyecto
  async setupProject(codeData) {
    const workDir = this.projectConfig.workingDir;
    
    // Limpiar directorio anterior
    if (fs.existsSync(workDir)) {
      fs.rmSync(workDir, { recursive: true });
    }
    fs.mkdirSync(workDir, { recursive: true });

    // Crear archivos
    for (const file of codeData.files) {
      const filePath = path.join(workDir, file.path);
      const fileDir = path.dirname(filePath);
      
      fs.mkdirSync(fileDir, { recursive: true });
      fs.writeFileSync(filePath, file.content);
      console.log(`üìÑ Creado: ${file.path}`);
    }

    // Ejecutar setup commands
    for (const command of codeData.setup_commands || []) {
      try {
        await execAsync(command, { cwd: workDir });
        console.log(`‚úÖ Ejecutado: ${command}`);
      } catch (error) {
        console.log(`‚ö†Ô∏è Warning en: ${command}`, error.message);
      }
    }
  }

  // üß™ TESTING: Ejecutar tests
  async runTests() {
    const workDir = this.projectConfig.workingDir;
    
    try {
      // Intentar ejecutar tests (por defecto node test.js si no hay package.json)
      let command = 'node test.js';
      
      // Verificar si existe package.json y tiene script test
      const packagePath = path.join(workDir, 'package.json');
      if (fs.existsSync(packagePath)) {
        const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
        if (pkg.scripts && pkg.scripts.test) {
          command = 'npm test';
        }
      }
      
      const { stdout, stderr } = await execAsync(command, { 
        cwd: workDir,
        timeout: 30000 
      });
      
      return {
        success: true,
        output: stdout,
        errors: stderr,
        command: command
      };
    } catch (error) {
      return {
        success: false,
        output: error.stdout || '',
        errors: error.stderr || error.message,
        command: 'test execution'
      };
    }
  }

  
  // üì§ GITHUB: Subir c√≥digo (versi√≥n simplificada para testing)
  async pushToGitHub(codeData, plan) {
    console.log('üì§ push a GitHub...');
    /*
    // Por ahora solo simulamos - puedes habilitar el push real despu√©s
    const mockUrl = `https://github.com/${this.projectConfig.owner}/${this.projectConfig.repo}/pull/mock-${this.currentTask.id}`;
    
    // Guardar c√≥digo localmente para revisi√≥n
    const outputDir = `./output_${this.currentTask.id}`;
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir);
    }
    
    for (const file of codeData.files) {
      fs.writeFileSync(path.join(outputDir, file.path), file.content);
    }
    
    console.log(`üíæ C√≥digo guardado en: ${outputDir}`);
    console.log(`üîó Mock GitHub URL: ${mockUrl}`);
    
    return mockUrl;*/
    
    //PUSH REAL A GITHUB:

    const workDir = this.projectConfig.workingDir;
    const branch = `pm-bot/task-${this.currentTask.id}`;
    
    try {
      console.log('üì§ Haciendo push REAL a GitHub...');
      
      // 1. Verificar que el repo existe
      try {
        const repoCheck = await this.github.rest.repos.get({
          owner: this.projectConfig.owner,
          repo: this.projectConfig.repo
        });
        console.log(`‚úÖ Repositorio encontrado: ${repoCheck.data.full_name}`);
      } catch (error) {
        if (error.status === 404) {
          console.log('üìÅ Repositorio no existe, cre√°ndolo...');
          await this.github.rest.repos.createForAuthenticatedUser({
            name: this.projectConfig.repo,
            description: 'PM Bot Generated Projects',
            private: false
          });
          console.log('‚úÖ Repositorio creado exitosamente');
          
          // Esperar un momento para que se propague
          await new Promise(resolve => setTimeout(resolve, 2000));
        } else {
          throw error;
        }
      }
      
      // 2. Detectar branch por defecto
      let defaultBranch = 'main';
      try {
        const branches = await this.github.rest.repos.listBranches({
          owner: this.projectConfig.owner,
          repo: this.projectConfig.repo
        });
        
        if (branches.data.length > 0) {
          // Buscar main o master
          const mainBranch = branches.data.find(b => b.name === 'main');
          const masterBranch = branches.data.find(b => b.name === 'master');
          defaultBranch = mainBranch ? 'main' : (masterBranch ? 'master' : branches.data[0].name);
        }
        console.log(`üåø Branch base detectado: ${defaultBranch}`);
      } catch (error) {
        console.log('‚ö†Ô∏è No se pudo detectar branches, usando main');
      }
      
      // 3. Configurar Git local
      await execAsync('git init', { cwd: workDir });
      
      const repoUrl = `https://${process.env.GITHUB_TOKEN}@github.com/${this.projectConfig.owner}/${this.projectConfig.repo}.git`;
      
      try {
        await execAsync(`git remote add origin ${repoUrl}`, { cwd: workDir });
      } catch (error) {
        // Remote ya existe, actualizarlo
        await execAsync(`git remote set-url origin ${repoUrl}`, { cwd: workDir });
      }
      
      // 4. Configurar usuario
      await execAsync('git config user.email "pm-bot@example.com"', { cwd: workDir });
      await execAsync('git config user.name "PM Bot"', { cwd: workDir });
      
      // 5. Hacer commit
      await execAsync('git add .', { cwd: workDir });
      await execAsync(`git commit -m "ü§ñ PM Bot: ${plan.summary}

  Tarea: ${this.currentTask.description}
  Archivos: ${codeData.files.map(f => f.path).join(', ')}

  Auto-generado por PM Bot v1.0"`, { cwd: workDir });
      
      // 6. Intentar push a diferentes branches
      let pushSuccess = false;
      
      // Primero intentar crear branch desde el branch por defecto
      try {
        await execAsync(`git fetch origin`, { cwd: workDir });
        await execAsync(`git checkout -b ${branch}`, { cwd: workDir });
        await execAsync(`git push origin ${branch}`, { cwd: workDir });
        pushSuccess = true;
        console.log(`‚úÖ Push exitoso al branch: ${branch}`);
      } catch (error) {
        console.log('‚ö†Ô∏è Push a branch nuevo fall√≥, intentando push directo...');
        
        // Si falla, hacer push directo a main/master
        try {
          await execAsync(`git checkout -B ${defaultBranch}`, { cwd: workDir });
          await execAsync(`git push origin ${defaultBranch}`, { cwd: workDir });
          pushSuccess = true;
          console.log(`‚úÖ Push directo exitoso a: ${defaultBranch}`);
          
          // Si es push directo, no crear PR
          const repoUrl = `https://github.com/${this.projectConfig.owner}/${this.projectConfig.repo}`;
          return repoUrl;
          
        } catch (directPushError) {
          console.error('‚ùå Push directo tambi√©n fall√≥:', directPushError.message);
          throw directPushError;
        }
      }
      
      // 7. Crear Pull Request solo si hicimos push a branch separado
      if (pushSuccess && branch !== defaultBranch) {
        try {
          const pr = await this.github.rest.pulls.create({
            owner: this.projectConfig.owner,
            repo: this.projectConfig.repo,
            title: `ü§ñ PM Bot: ${plan.summary}`,
            head: branch,
            base: defaultBranch,
            body: `## ü§ñ Generado autom√°ticamente por PM Bot

  **Tarea:** ${this.currentTask.description}

  **Archivos creados:**
  ${codeData.files.map(f => `- \`${f.path}\` - ${f.type}`).join('\n')}

  **‚è±Ô∏è Tiempo:** ${Math.round((new Date() - this.currentTask.startTime) / 1000)}s

  **üß™ Tests:** ‚úÖ Validados autom√°ticamente

  ---
  *Generado por PM Bot v1.0 | Task ID: ${this.currentTask.id}*`
          });
          
          console.log('‚úÖ Pull Request creado exitosamente!');
          return pr.data.html_url;
          
        } catch (prError) {
          console.error('‚ùå Error creando PR:', prError.message);
          // Retornar URL del repo aunque falle el PR
          return `https://github.com/${this.projectConfig.owner}/${this.projectConfig.repo}/tree/${branch}`;
        }
      }
      
    } catch (error) {
      console.error('‚ùå Error general en GitHub push:', error.message);
      
      // Fallback: guardar localmente
      const outputDir = `./output_${this.currentTask.id}`;
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }
      
      for (const file of codeData.files) {
        fs.writeFileSync(path.join(outputDir, file.path), file.content);
      }
      
      console.log(`üíæ C√≥digo guardado localmente en: ${outputDir}`);
      return `file://${path.resolve(outputDir)}`;
    }
  }

  // ‚úÖ REPORTE: Informar √©xito
  async reportSuccess(plan, testResults, githubUrl) {
    const report = `
üéâ TAREA COMPLETADA EXITOSAMENTE

üìã Tarea: ${this.currentTask.description}
‚è±Ô∏è  Tiempo: ${Math.round((new Date() - this.currentTask.startTime) / 1000)}s
üß™ Tests: ${testResults.success ? 'PASARON' : 'FALLARON'}
üì§ GitHub: ${githubUrl}

‚úÖ Ready for review!
    `;
    
    console.log(report);
    
    this.currentTask.status = 'completed';
    this.currentTask.result = { success: true, githubUrl, testResults };
  }

  // ‚ùå ERROR: Manejar fallos
  async handleTestFailure(testResults) {
    console.log('üîß Tests fallaron, los detalles:');
    console.log('Output:', testResults.output);
    console.log('Errors:', testResults.errors);
    
    // Por simplicidad, por ahora no auto-fix
    console.log('üí° Revisa el c√≥digo en temp_project/ para debuggear');
    
    this.currentTask.status = 'failed';
    this.currentTask.testResults = testResults;
  }

  async handleError(error) {
    console.error('üö® Error en PM Bot:', error.message);
    this.currentTask.status = 'error';
    this.currentTask.error = error.message;
  }

  // üìä STATUS: Estado actual
  getStatus() {
    return {
      isWorking: this.isWorking,
      queueLength: this.taskQueue.length,
      currentTask: this.currentTask,
      uptime: process.uptime()
    };
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// üöÄ FUNCI√ìN PRINCIPAL
async function main() {
  console.log('ü§ñ PM Bot v1.0 - Iniciando...');

  try {
    const pmBot = new SimplePM();

    if (process.argv[2]) {
      // Ejecutar tarea desde command line
      await pmBot.processTask(process.argv[2]);
    } else {
      // Tarea de ejemplo
      console.log('\nüéØ No se proporcion√≥ tarea, ejecutando ejemplo...');
      await pmBot.processTask("Crear funci√≥n JavaScript que sume dos n√∫meros con tests");
    }

    console.log('\n‚úÖ PM Bot termin√≥ la ejecuci√≥n');
    
  } catch (error) {
    console.error('üí• Error fatal:', error.message);
    process.exit(1);
  }
}

// Manejar cierre graceful
process.on('SIGINT', () => {
  console.log('\nüëã PM Bot deteniendo...');
  process.exit(0);
});

// Ejecutar si es el archivo principal
if (require.main === module) {
  main().catch(console.error);
}

module.exports = SimplePM;
